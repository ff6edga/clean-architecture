05 웹 어댑터 구현하기
================
- [헥사고날 아키텍쳐](https://mesh.dev/20210910-dev-notes-007-hexagonal-architecture/)에서의 **웹 어댑터**
<img width="304" alt="image" src="https://github.com/ff6edga/clean-architecture/assets/8231865/be9abb61-31d8-4a96-b6de-99e92755a360">



#### 의존성 역전
- 웹 어댑터 - 어플리케이션 서비스간 통신


  <img width="740" alt="image" src="https://github.com/ff6edga/clean-architecture/assets/8231865/e9430a50-7515-4d31-a9a4-ee6de2049876">

- 웹어댑터를 인커밍 어댑터로 활용하는 경우
- 인커밍 어댑터 = 주도하는 어댑터 = 제어 흐름 방향이 같은 어댑터
- 웹 어댑터 - 서비스간 연동에서 간접 계층(포트, 의존성 역전법칙) 이 있는 이유는?
  - 어플리케이션의 외부 접근들을 포트를 통해 쉽게 유지보수 한다. 
  - 계층간 의존성 전파(ch2 4p 지름길을 택하기 쉬워진다)를 차단한다.

<img width="733" alt="image" src="https://github.com/ff6edga/clean-architecture/assets/8231865/654246b0-839d-4459-8f1f-7bdf768b9c25">


- 웹 어댑터를 아웃커밍 어댑터로 활용하는 경우 (WebSocket Controller)

#### 웹 어댑터의 책임
```
- Http Request 역직렬화
- 웹 어댑터 입력 모델 검증 (다음 단계 매핑을 위한 검증)
- 웹 어댑터 입력 모델 <-> 유스케이스 입력 모델 매핑
- 유스케이스 호출
- Http Response 직렬화
- 에러 처리
```
- 책임이 다소 많다고 느껴져도 역할 중 일부를 다른 계층을 넘겨서는(=오염시켜서는) 안된다
  - 오염된 계층은 오염된 만큼 범용성을 잃게 된다. 
  - ex 일부 http 처리를 하는 OrderService
  - 웹 대신 도메인과 애플리케이션 계층부터 개발하는 것이 경계 유지에 도움이 될 수 있다.

#### 컨트롤러 나누기

- 특정 도메인에 컨트롤러는 적은것 보다 많은 것이 좋다

<img width="751" alt="image" src="https://github.com/ff6edga/clean-architecture/assets/8231865/cc8df371-32f6-458c-b895-18af746a93eb">


- 특정 도메인에 컨트롤러가 적을때의 단점 (=나눠지지 않았을때의 단점)
  - 코드량 자체가 많아지므로 가독성과 유지보수 면에서 아쉽다
  - 테스트 코드도 많아지므로 파악하기 어렵다. 
  - 다양한 모델을 다룰수 있기때문에 다양한 접근과 재활용이 발생한다. (=유지보수가 어려워진다.) 

- 최대한 개별 유스케이스에 충실한 컨트롤러를 작성하자.
  - ex : SendMoneyController
  - 대부분 컨트롤러 자체 모델을 갖기 때문에 불필요한 재활용을 줄이고, 유스케이스에 꼭 필요한 모델과 필드만을 작성하게 된다.

- 컨트롤러 / 서비스 네이밍에 대해서도 좀 더 고민하자.
  - CreateAccount 보다는 RegisterAccont가 전달력 있는 표현 (케바케 but CRUD 네이밍은 개발자 친화적)

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까? 
 - 계층간 역할에만 충실하게 구현하자
   - 웹 어댑터는 only HTTP 처리, 어플리케이션 서비스는 only 도메인 로직
   - **계층별 모듈의 범용성이 좋아진다**
 - 웹컨트롤러는 최대한 모델을 공유하지 않는 작은 단위로 작성하자.
   - **테스트가 쉬워지고, 유지보수 비용이 저렴해진다.** 
